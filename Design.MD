
# 设计

### 术语

```
脚本类型 = Python | Bash
脚本代码 = 代码数据 + 脚本类型
状态 = 未运行 | 正在运行
间隔时间 = (int >= 0)
ID = (int >= 0)
任务 = ID + 标题（唯一） + 脚本代码 + 状态 + 间隔时间 + 最大执行次数 + 上次运行时间 + PID
任务列表 = [ 任务, 任务, ... ]
```

### 功能设计
1. 显示任务列表
   1. 描述：用户打开页面后看到任务列表；列表每项包含任务的标题、任务的状态（文本）、间隔时间、下一次运行时间、启动/停止/删除该任务
   2. 流程
      1. 前端向后端发送获取任务列表请求
      2. 后端从数据库读取所有任务列表及状态，发送到前端
      3. 前端展示任务列表
2. 添加任务
   1. 描述：用户在文本区域输入脚本代码；选择脚本类型；设置间隔时间（默认为0）；点击添加
   2. 流程
      1. 前端提取任务数据并处理为JSON字符串，发送到后端；
      2. 后端接收到任务后，解析为任务对象，并将对象添加到数据库中；
      3. 后端完成后向前端发送确认码；
      4. 前端收到确认码后刷新任务列表
3. 启动任务
   1. 描述：用户点击未启动任务的启动按钮，启动该任务
   2. 流程
      1. 前端将启动任务请求发送到后端
      2. 后端启动任务
         1. 后端从数据库读取任务信息，将任务的脚本代码写入到文件中
         2. 后端创建新进程，将进程的三个STDIO重定向到三个管道，并在主进程中使用IO多路复用监听三个管道
            1. 将STDOUT、STDERR存储到固定大小的缓冲区中
         3. 新进程中执行脚本文件
4. 查看任务信息
   1. 描述：用户点击任务列表某个任务的标题；进入任务信息界面，能够实时看到任务的输出内容
   2. 流程
      1. 进入任务信息界面时，前端向后端发起websocket连接
         1. 前端注册websocket的相关事件：onmessage收取数据显示到STDOUT/STDERR中
         2. 前端使用websocket发送数据
      2. 后端接收到websocket连接后，建立连接，并注册相关事件
         1. 收到前端的stdin数据，则将其发送到任务对应的STDIN管道
         2. 任务STDOUT/STDERR管道的内容通过websocket发送到前端
         3. websocket连接断开时不停止进程
5. 停止任务
   1. 描述：对于已启动的任务，用户点击停止按钮，停止执行该任务
   2. 流程
      1. 前端将停止任务请求发送到后端
      2. 后端检查任务是否在运行，若未运行则啥也不干
      3. 若在运行，获取任务的PID直接杀死进程
      4. 返回数据
6. 删除任务
   1. 描述：用户点击删除按钮，如果任务在执行，则询问，并在确定后停止任务，之后删除任务
   2. 流程
      1. 前端点击删除按钮
      2. 向后端发送数据查询任务状态
      3. 若任务已启动，则询问用户是否停止该任务并删除
         1. 若是，则执行停止任务，并等待
         2. 否则结束，退出
      4. 向后端发送删除任务请求
      5. 后端校验任务是否在运行，若运行，则返回错误码（状态异常）
      6. 否则，将任务从db中删除

### 依赖的库

1. 包管理 - conan
2. http/websocket库 - uWebsocket
3. 数据库 - leveldb
4. IO事件 - libevent

### 后端进程设计

参考[process_data_design.png](misc/process_data_design.png)

进程

- 主进程，同时也是HTTP服务的进程
  - ws线程
- 任务管理进程
  - 子进程资源回收/定时器设置线程
- 脚本执行进程

通信/共享的数据对象

- websocket套接字对象
  - 共享者：HTTP进程，ws线程
  - 目的：向ws主动发送数据
  - 原因：HTTP进程无法主动向ws发送数据，因此使用单独线程执行发送
- Unix套接字
  - 共享者：HTTP进程，ws线程，任务管理进程
  - 目的
    - HTTP进程 ---- 启动/删除/停止任务 ----> 任务管理进程
    - HTTP进程 ---- 要发送到任务的数据 ----> 任务管理进程
    - 任务管理进程 ---- 任务脚本的输出数据 ----> ws线程
  - 原因：任务管理进程既需要读取数据也需要输出数据，因此使用Unix套接字
- 三个STDIO管道
  - 共享者：任务管理进程，脚本进程
  - 目的：重定向STDIO
- leveldb对象
  - 共享者：HTTP进程，任务管理进程
  - 目的：管理任务
  - 同步：同一时刻只有一个进程能够打开leveldb数据库，因此无需同步

### 数据对象设计

任务 == task
脚本 == script

```
task = id
       title
       script_code
       script_type      : 脚本类型
       status
       pid
       interval         : 运行间隔时间
       maxTimes         : 最大执行次数
       exitCode         : 上一次退出时的状态码
       exitTimestamp    : 上一次退出的时间戳(秒)

status = idle | running

script_type = Python | Bash

```

TODO 任务状态页面 每5s/每次执行任务操作后 更新任务列表
TODO 更新进程的执行流

### 进程执行流

注：除了脚本STDIO的管道外，**所有其它创建的fd都要CLOSE_ON_EXEC**

1. HTTP进程
   1. 创建 UnixSock1,UnixSock2
      1. 关闭 UnixSock2
   2. fork
      1. 关闭 UnixSock1
      2. 启动任务管理进程
   3. 创建任务ID到Websocket的映射taskToWs
   4. thread
      1. 启动ws线程
   5. HTTP事件处理
      1. 添加任务 - 构造并添加到leveldb
      2. 启动任务
         1. 任务ID + 命令:启动 -> UnixSock1
      3. 停止任务
         1. 任务ID + 命令:删除 -> UnixSock1
      4. 删除任务
         1. 停止任务
         2. 从leveldb移除
      5. 任务详情Websocket连接
         1. onopen
            1. 存储到Ws映射
            2. 任务ID + 命令:重定向输出 -> UnixSock1
         2. onmessage
            1. 任务ID + message + 命令:输入 -> UnixSock1
         3. onclose
            1. 任务ID + 命令:取消重定向 -> UnixSock1
            2. 从Ws映射中移除
2. ws线程
   1. libevent监听UnixSock1的读事件
      1. 任务ID + 内容 <- UnixSock1
         1. 根据任务ID获取ws
         2. ws.send(内容)
3. 任务管理进程
   1. 创建libevent对象
   2. 创建信号量sem与线程通信
   3. thread -> 任务回收线程
   4. libevent监听 UnixSock2
      1. 任务ID + 命令:启动
         1. 创建三个管道
         2. 将管道描述符记录到任务信息中
         3. 将STDOUT/STDERR的读事件添加到libevent
         4. fork并关闭对端
            1. exec执行任务
         5. 更新任务的执行次数
         6. sem加1，通知任务回收线程
      2. 任务ID + 命令:删除
      3. 任务ID + 命令:重定向输出
      4. 任务ID + 命令:取消重定向
      5. 任务ID + message + 命令:输入
      6. 某个管道的输出
         1. 
4. 任务回收线程
   1. 当sem大于1时，使用wait回收进程
   2. 子进程回收后，更新任务状态和退出码

